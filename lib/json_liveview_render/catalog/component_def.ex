defmodule JsonLiveviewRender.Catalog.PropDef do
  @moduledoc "Prop definition metadata used by catalog components."

  @enforce_keys [:name, :type]
  defstruct [
    :name,
    :type,
    :doc,
    :validator,
    :binding_type,
    required: false,
    default: nil,
    values: nil
  ]

  @type prop_type ::
          :string
          | :integer
          | :float
          | :boolean
          | :map
          | :custom
          | :enum
          | {:list, prop_type()}

  @type t :: %__MODULE__{
          name: atom(),
          type: prop_type(),
          required: boolean(),
          default: term(),
          doc: String.t() | nil,
          values: [term()] | nil,
          validator: (term() -> boolean()) | nil,
          binding_type: prop_type() | nil
        }

  @doc "Returns true if `value` satisfies the type contract defined by `prop_def`."
  @spec valid?(term(), t()) :: boolean()
  def valid?(nil, %__MODULE__{required: false}), do: true
  def valid?(nil, _), do: false
  def valid?(value, %__MODULE__{type: :string}), do: is_binary(value)
  def valid?(value, %__MODULE__{type: :integer}), do: is_integer(value)
  def valid?(value, %__MODULE__{type: :float}), do: is_integer(value) or is_float(value)
  def valid?(value, %__MODULE__{type: :boolean}), do: is_boolean(value)
  def valid?(value, %__MODULE__{type: :map}), do: is_map(value)

  def valid?(value, %__MODULE__{type: :enum, values: values}) do
    values = values || []
    value in values or to_string(value) in Enum.map(values, &to_string/1)
  end

  def valid?(value, %__MODULE__{type: {:list, inner}}) when is_list(value) do
    Enum.all?(value, fn item -> valid?(item, %__MODULE__{name: :_item, type: inner}) end)
  end

  def valid?(value, %__MODULE__{type: :custom, validator: validator})
      when is_function(validator, 1),
      do: validator.(value)

  def valid?(_value, _prop), do: false
end

defmodule JsonLiveviewRender.Catalog.ComponentDef do
  @moduledoc "Component definition generated by `JsonLiveviewRender.Catalog` DSL."

  alias JsonLiveviewRender.Catalog.PropDef

  @enforce_keys [:name]
  defstruct [
    :name,
    description: nil,
    props: %{},
    slots: [],
    permission: nil
  ]

  @type t :: %__MODULE__{
          name: atom(),
          description: String.t() | nil,
          props: %{optional(atom()) => PropDef.t()},
          slots: [atom()],
          permission: term() | nil
        }

  @spec new(atom()) :: t()
  def new(name) when is_atom(name), do: %__MODULE__{name: name}

  @spec put_description(t(), String.t()) :: t()
  def put_description(component, description) when is_binary(description) do
    %{component | description: description}
  end

  @spec put_prop(t(), PropDef.t()) :: t()
  def put_prop(component, %PropDef{name: prop_name} = prop) do
    %{component | props: Map.put(component.props, prop_name, prop)}
  end

  @spec put_slot(t(), atom()) :: t()
  def put_slot(component, slot_name) when is_atom(slot_name) do
    %{component | slots: Enum.uniq(component.slots ++ [slot_name])}
  end

  @spec put_permission(t(), term()) :: t()
  def put_permission(component, required_role) do
    %{component | permission: required_role}
  end

  @spec prop_names(t()) :: [atom()]
  def prop_names(component), do: component.props |> Map.keys() |> Enum.sort()
end
